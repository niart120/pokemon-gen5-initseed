# ポケモンBW・BW2 オフセット計算 実装仕様詳細

本資料は、ポケモンブラック・ホワイト（BW）およびブラック2・ホワイト2（BW2）での「オフセット」計算を実装するための手順とアルゴリズムを、実装者目線で詳細に記載する。

---

## 1. オフセット計算とは

「オフセット」とは、ゲーム起動時に決定される初期seed（64bit値）から、ゲーム内部処理による乱数消費を経て、任意のイベント（TID/SID決定やブラックシティ住人決定など）が発生する直前までに進んだ乱数生成器の状態（消費回数）を示す値である。

---

## 2. 前提：乱数生成器仕様

- 乱数生成には線形合同法を用いる。
- 状態は64bit整数値（以降「seed」と呼ぶ）。
- seedの進め方は以下の通り：

  ```
  S[n+1] = (S[n] * 0x5D588B656C078965 + 0x269EC3) mod 2^64
  ```

- 各イベントでは、seedの上位32bitを「乱数値」として使用する。
- 初期seed（S0）は、SHA-1で52byteのデータ（起動時刻やパラメータなど）をハッシュ化し、先頭8byteを64bit符号なし整数として用いる。

---

## 3. 各イベントにおける乱数消費フロー（BW/BW2共通パターン）

### (A) BW：始めから（セーブデータ有り）

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. Probability Table（PT）操作を2回実施（PT×2）
4. チラーミィ用PID決定（seedを1回進めて上位32bit値をそのまま、またはxor 0x00010000）
5. チラーミィ用ID決定（seedを1回進める。事実上0固定）
6. TID/SID決定（seedを1回進め、(乱数値 * 0xFFFFFFFF) >> 32 の下2byteをTID、上2byteをSIDに割当）
7. PT操作を4回実施（PT×4）
8. 表住人決定：10人分決定。乱数値の範囲分割方式で住人番号を決定し、選出済み住人は次以降の候補から除外
9. 裏住人決定：3人分決定。上と同様

### (B) BW：始めから（セーブデータ無し）

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. PT操作を3回実施（PT×3）
4. チラーミィ用PID決定
5. チラーミィ用ID決定（seedを1回進める）
6. TID/SID決定
7. seedを1回進める（Rand×1）
8. PT操作を4回実施（PT×4）
9. 表住人決定（10人）
10. 裏住人決定（3人）

### (C) BW：続きから始める

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. PT操作を5回実施（PT×5）

### (D) BW2：始めから（思い出リンク済みセーブデータ有り）

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. PT操作を1回実施（PT×1）
4. seedを2回進める（Rand×2）
5. PT操作を1回実施（PT×1）
6. seedを2回進める（Rand×2）
7. チラチーノ用PID決定
8. チラチーノ用ID決定（seedを1回進める）
9. TID/SID決定

### (E) BW2：始めから（思い出リンク無しセーブデータ有り）

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. PT操作を1回実施（PT×1）
4. seedを3回進める（Rand×3）
5. PT操作を1回実施（PT×1）
6. seedを2回進める（Rand×2）
7. チラチーノ用PID決定
8. チラチーノ用ID決定（seedを1回進める）
9. TID/SID決定

### (F) BW2：始めから（セーブデータ無し）

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. PT操作を1回実施（PT×1）
4. seedを2回進める（Rand×2）
5. PT操作を1回実施（PT×1）
6. seedを4回進める（Rand×4）
7. PT操作を1回実施（PT×1）
8. seedを2回進める（Rand×2）
9. チラチーノ用PID決定
10. チラチーノ用ID決定（seedを1回進める）
11. TID/SID決定

### (G) BW2：続きから始める（思い出リンク済み）

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. PT操作を1回実施（PT×1）
4. seedを2回進める（Rand×2）
5. PT操作を4回実施（PT×4）
6. Extra処理

### (H) BW2：続きから始める（思い出リンク無し）

1. S0（SHA-1）から開始
2. seedを1回進める（Rand×1）
3. PT操作を1回実施（PT×1）
4. seedを3回進める（Rand×3）
5. PT操作を4回実施（PT×4）
6. Extra処理

---

## 4. Probability Table（PT）操作詳細

PT操作は以下の流れで実装する：

1. 現在のseedの上位32bitをRとする。
2. `r = (R * 101) >> 32` を計算する（0～100の整数値になる）。
   - この計算は、32bit整数Rを101倍した結果の上位32bitを取得することで、
   - 0から100までの範囲の値を均等に分布させる確率計算である。
3. PTは6段階（L1〜L6）あり、各段階で次のテーブルを参照する：

   ```
   L1 {50,100,100,100,100}
   L2 {50, 50,100,100,100}
   L3 {30, 50,100,100,100}
   L4 {25, 30, 50,100,100}
   L5 {20, 25, 33, 50,100}
   L6 {100,100,100,100,100}
   ```

4. L1からL6まで各レベルで、左から順に閾値をチェックする。値が100の場合は次のレベルへ進む。100でない場合は乱数を消費し、`r <= 閾値` なら次のレベルへ進む。
5. すべてのレベル（L6）を完了するまで、この処理を繰り返す。

### PT操作の具体例
初期seed例：`672C1C3C3D71E125` のPT×2処理

**1回目のPT操作:**
| Frame | Rand値     | (R*101)>>32 | 判定 |
|-------|------------|-------------|------|
| 1     | 67FA0457   | 41          | L1の50以下→L2へ |
| 2     | D6A4EF21   | 84          | L2の50より大きい |
| 3     | E3B3421B   | 89          | L2の50より大きい |
| 4     | A0C3E2A9   | 63          | L2の100以下→L3の30より大きい |
| 5     | 50DE87BE   | 31          | L3の50以下→L4へ |
| 6     | 7BE03615   | 48          | L4の25より大きい |
| 7     | D4E8FAEC   | 83          | L4の30より大きい |
| 8     | 8E51F332   | 56          | L4の50より大きい |
| 9     | D15DA049   | 82          | L4の100以下→L5の20より大きい |
| 10    | 530E4EE6   | 32          | L5の25より大きい |
| 11    | 27BE3D13   | 15          | L5の33以下→L6へ |
| 12    | C6F25ADA   | 78          | L6の100以下→乱数消費なし |

**2回目のPT操作:**
12番目から継続...（詳細省略）

**結果:** PT×2で計11回の乱数が消費される

---

## 5. チラーミィ/チラチーノ用PID・ID決定方式

- 指定回数乱数を進め、上位32bitをPIDとする（xor 0x00010000の分岐あり）。
- ID決定は乱数値の0固定（R*0>>32）。このイベントで乱数消費が発生するか否かは仕様差分あり（口パク消費説あり）。

---

## 6. TID/SID決定方式

- seedを進め、上位32bitをRとする。
- `(R * 0xFFFFFFFF) >> 32` の下位2byte（16bit）がTID、上位2byteがSIDとなる。
- この計算式の詳細：
  - Rを0xFFFFFFFF（32bit最大値）で乗算
  - 結果の上位32bitを取得することで、0からFFFFFFFFまでの範囲を均等分布
  - 下位16bit（0x0000～0xFFFF）がTID（0～65535）
  - 上位16bit（0x0000～0xFFFF）がSID（0～65535）

### 計算例
```
R = 0xEC8CA73C の場合
(0xEC8CA73C * 0xFFFFFFFF) >> 32 = 0xEC8CA73B
TID = 0xA73B = 42811
SID = 0xEC8C = 60556
```

---

## 7. ブラックシティ/ホワイトフォレスト住人決定処理

BWでは以下の住人決定処理が行われる：

- 表住人決定：10回の乱数消費
- 裏住人決定：3回の乱数消費

**合計：13回の乱数消費**

各住人決定において、seedを1回進めて住人を選択する。内部の抽選ロジックや重み付け処理の詳細は実装上考慮する必要がなく、単純に指定回数分の乱数消費として扱う。

---

## 8. Extra処理（BW2の特定状況）

BW2で「続きから始める」場合にのみ実行される特殊な乱数消費処理：

1. 3回連続で乱数を進め、各seedの上位32bitをRとする
2. 各Rに対して `(R * 15) >> 32` を計算し、3つの値を取得する
3. 3つの値がすべて異なるかチェックする
4. 同じ値が含まれている場合は、再度手順1から繰り返す
5. 3つとも異なる値になるまでこの処理を続ける

### Extra処理の疑似コード
```python
def extra_process(seed):
    while True:
        # 3つの値を生成
        seed = next_seed(seed)
        R1 = seed >> 32
        value1 = (R1 * 15) >> 32
        
        seed = next_seed(seed)
        R2 = seed >> 32
        value2 = (R2 * 15) >> 32
        
        seed = next_seed(seed)
        R3 = seed >> 32
        value3 = (R3 * 15) >> 32
        
        # 3つとも異なるかチェック（どれか2つでも同じなら継続）
        if not (value1 == value2 or value2 == value3 or value3 == value1):
            break
    
    return seed
```

---

## 9. 実装上の注意点

- offsetKeisan等のツールと結果を比較する場合、初期seed（S0）・初期乱数値（S1）など「何番目を1とするか」の基準がツールごとに異なるため、意図する基準に合わせて計算を始める必要がある。
- ゲーム内部の特殊な乱数消費（徘徊・大量発生・ジョインアベニュー等）も、必要に応じて乱数消費回数に反映する。
- チラーミィのID決定での乱数消費有無、住人決定ロジックの住人リスト/重みはバージョンにより異なる場合があるため、対応するバージョン仕様で実装する。

---

## 10. 疑似コード例（BW: 始めから/セーブ有り）

```python
def calculate_bw_offset_new_game_with_save(initial_data):
    # S0の生成（SHA-1ハッシュ）
    seed = SHA1_hash_52bytes(initial_data)  # S0
    
    # 基本的な乱数進行
    seed = next_seed(seed)  # Rand×1, S1
    
    # PT操作×2
    for _ in range(2):
        seed = probability_table_process(seed)
    
    # チラーミィPID決定
    seed = next_seed(seed)
    chiramii_pid = seed >> 32
    # 色違い判定: (上位16bit xor 下位16bit) <= 7
    is_shiny = ((chiramii_pid >> 16) ^ (chiramii_pid & 0xFFFF)) <= 7
    
    # チラーミィID決定（0固定）
    seed = next_seed(seed)
    chiramii_id = 0  # (R * 0) >> 32 = 0
    
    # TID/SID決定
    seed = next_seed(seed)
    R = seed >> 32
    tid_sid_combined = (R * 0xFFFFFFFF) >> 32
    TID = tid_sid_combined & 0xFFFF
    SID = (tid_sid_combined >> 16) & 0xFFFF
    
    # PT操作×4
    for _ in range(4):
        seed = probability_table_process(seed)
    
    # 表住人決定（10回の乱数消費）
    for _ in range(10):
        seed = next_seed(seed)
    
    # 裏住人決定（3回の乱数消費）
    for _ in range(3):
        seed = next_seed(seed)
    
    # オフセット = 初期seedからの消費回数
    return calculate_consumed_count(initial_seed, seed)

def probability_table_process(seed):
    """PT操作の詳細実装"""
    PT_TABLES = [
        [50, 100, 100, 100, 100],  # L1
        [50, 50, 100, 100, 100],   # L2
        [30, 50, 100, 100, 100],   # L3
        [25, 30, 50, 100, 100],    # L4
        [20, 25, 33, 50, 100],     # L5
        [100, 100, 100, 100, 100]  # L6
    ]
    
    for level in range(6):  # L1からL6まで
        for j in range(5):  # 各レベルで最大5つの閾値をチェック
            if PT_TABLES[level][j] == 100:
                # 確率が100なら、次のレベルへ
                break
            
            seed = next_seed(seed)
            R = seed >> 32
            r = (R * 101) >> 32
            
            if r <= PT_TABLES[level][j]:
                # 取得した確率がテーブルの値以下なら次のレベルへ
                break
    
    return seed

def next_seed(seed):
    """線形合同法による次のseed生成"""
    return (seed * 0x5D588B656C078965 + 0x269EC3) & 0xFFFFFFFFFFFFFFFF

def SHA1_hash_52bytes(data):
    """52バイトデータのSHA-1ハッシュから64bit値を生成"""
    import hashlib
    hash_result = hashlib.sha1(data).digest()
    return int.from_bytes(hash_result[:8], 'big')
```

---

## 11. まとめ

- 各バージョン・開始方法ごとに「乱数消費フロー（乱数を何回どのタイミングで進めるか）」を正確に実装する。
- PT操作や住人決定などは、必ず仕様通りの分岐・範囲割り当てを行う。
- 一連の乱数消費回数がオフセットとなる。

---